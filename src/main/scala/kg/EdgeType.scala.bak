package kg

import scala.collection.mutable.HashMap

abstract class EdgeType {} // EdgeType    

class EdgeType(_name : String){
    
    //The EdgeTypes for which this node can be either a subject or object
    private var subjectNodes = Vector[NodeType]()
    private var objectNodes  = Vector[NodeType]()

    
    /*
     * The getters for the types of edges that a node of this type can
     * be either a subject or object for
     */
    def canLeadFrom(nt : NodeType) = subjectNodes.contains(nt)
    def canLeadTo  (nt : NodeType) = objectNodes.contains(nt)

    /*
     * The setters for the types of edges that a node of this type can
     * be either a subject or object for      
     *
     */
   
    def letLeadFrom(nt : NodeType) = {subjectNodes = subjectNodes :+ nt}
    def letLeadTo  (nt : NodeType) = {objectNodes  = objectNodes :+ nt}

} // EdgeType

object EdgeType{
    
}
object EdgeTypeTester extends App{
    val pass = "Pass"
    val fail = "Fail"

    val road       = new NodeType("road")
    val sensor     = new NodeType("sensor")
    val intersects = new EdgeType("intersects")
    val measures   = new EdgeType("measures")

    println("Testing associations for empty EdgeTypes")     

    println(s"\tintersects can not lead from road: ${if (!intersects.canLeadFrom(road)) pass else fail}")
    println(s"\tmeasures can not lead from road: ${if (!measures.canLeadFrom(road)) pass else fail}")
    println(s"\tintersects can not lead from sensor: ${if (!intersects.canLeadFrom(sensor)) pass else fail}")
    println(s"\tmeasures can not lead from sensor: ${if (!measures.canLeadFrom(sensor)) pass else fail}")
    println(s"\tintersects can not lead to road: ${if (!intersects.canLeadTo(road)) pass else fail}")
    println(s"\tmeasures can not lead to road: ${if (!measures.canLeadTo(road)) pass else fail}")
    println(s"\tintersects can not lead to sensor: ${if (!intersects.canLeadTo(sensor)) pass else fail}")
    println(s"\tmeasures can not lead to sensor: ${if (!measures.canLeadTo(sensor)) pass else fail}")

    println(s"Making associations...")
    
    measures.letLeadFrom(sensor)
    measures.letLeadTo(road)
    intersects.letLeadFrom(road)
    intersects.letLeadTo(road)

    println("Testing associations...")
   
    println(s"\tmeasures leads from sensor: ${if (measures.canLeadFrom(sensor)) pass else fail}")
    println(s"\tmeasures leads from road: ${if (!measures.canLeadFrom(road)) pass else fail}")
    println(s"\tmeasures leads to sensor: ${if (!measures.canLeadTo(sensor)) pass else fail}")
    println(s"\tmeasures leads to road: ${if (measures.canLeadTo(road)) pass else fail}")

    println(s"\tintersects leads from sensor: ${if (!intersects.canLeadFrom(sensor)) pass else fail}")
    println(s"\tintersects leads from road: ${if (intersects.canLeadFrom(road)) pass else fail}")
    println(s"\tintersects leads to sensor: ${if (!intersects.canLeadTo(sensor)) pass else fail}")
    println(s"\tintersects leads to road: ${if (intersects.canLeadTo(road)) pass else fail}")
    
    println("Testing add properties.")

    println(s"\tMeta information for measures before adding properties: ${measures.getMeta()}")
    println(s"\tMeta information for intersects before adding properties: ${intersects.getMeta()}")

    println()
    
    def afterProp(et : EdgeType, property : String) = {
        println(s"\tAfter adding ${property} property to ${et.getName()} EdgeType:")
        println(s"\t\tmeta: ${et.getMeta()}")
        println(s"\t\tnumProperties: ${et.numProperties()}")
        //println(s"\t\ttesting the propertyNameMap: ${if (nt.getMeta(nt.propertyNameMap(property)).equals(name)) pass else fail}")
    }

    measures.addProperty("frequency","String")
    afterProp(measures,"frequency")

    intersects.addProperty("lat","real")
    afterProp(intersects,"lat")

    intersects.addProperty("lon","real")
    afterProp(intersects,"lon")
        
} // EdgeTypeTester